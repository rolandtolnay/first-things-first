---
phase: 01-foundation-data-layer
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/providers/ThemeProvider.tsx
  - src/app/layout.tsx
  - src/components/ThemeToggle.tsx
  - src/app/globals.css
autonomous: true
must_haves:
  truths:
    - "User can toggle between light and dark mode"
    - "Theme persists across page refresh"
    - "No flash of wrong theme on page load"
    - "System theme preference is respected on first visit"
  artifacts:
    - path: "src/providers/ThemeProvider.tsx"
      provides: "next-themes provider wrapper"
      min_lines: 10
      contains: "ThemeProvider"
    - path: "src/components/ThemeToggle.tsx"
      provides: "Theme toggle button component"
      min_lines: 15
      contains: "useTheme"
  key_links:
    - from: "src/app/layout.tsx"
      to: "src/providers/ThemeProvider.tsx"
      via: "provider wrapping children"
      pattern: "ThemeProvider"
    - from: "src/components/ThemeToggle.tsx"
      to: "next-themes"
      via: "useTheme hook"
      pattern: "useTheme"
---

<objective>
Implement theme infrastructure with next-themes for seamless light/dark mode switching.

Purpose: Enable light and dark mode from day one, avoiding theme flash and supporting system preferences.
Output: Working theme toggle with persistence, zero-flicker page loads, and proper dark mode CSS.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/PITFALLS.md

From research - Theme Flash prevention:
- next-themes injects inline script before body renders
- Must use suppressHydrationWarning on html element
- ThemeProvider wraps app, not individual components

JARVIS aesthetic direction:
- Dark mode: Deep dark background (#0a0a0f), teal/cyan accents
- Light mode: Clean white/gray, subtle teal accents
- Both modes should feel polished and intentional
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ThemeProvider wrapper component</name>
  <files>src/providers/ThemeProvider.tsx</files>
  <action>
    Create a client component that wraps next-themes ThemeProvider:

    ```typescript
    'use client';

    import { ThemeProvider as NextThemesProvider } from 'next-themes';
    import { type ThemeProviderProps } from 'next-themes';

    export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
      return (
        <NextThemesProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
          {...props}
        >
          {children}
        </NextThemesProvider>
      );
    }
    ```

    Configuration rationale:
    - attribute="class": Adds .dark class to html element (Tailwind convention)
    - defaultTheme="system": Respects OS preference on first visit
    - enableSystem: Reacts to OS theme changes
    - disableTransitionOnChange: Prevents transition flash on theme switch

    This must be a client component ('use client') because next-themes uses React context.
  </action>
  <verify>Component imports correctly in layout.tsx</verify>
  <done>ThemeProvider wrapper created with correct configuration</done>
</task>

<task type="auto">
  <name>Task 2: Integrate ThemeProvider into layout and enhance CSS</name>
  <files>src/app/layout.tsx, src/app/globals.css</files>
  <action>
    Update layout.tsx to wrap children with ThemeProvider:

    ```typescript
    import { ThemeProvider } from '@/providers/ThemeProvider';

    export default function RootLayout({ children }) {
      return (
        <html lang="en" suppressHydrationWarning>
          <body className={`${inter.variable} antialiased`}>
            <ThemeProvider>
              {children}
            </ThemeProvider>
          </body>
        </html>
      );
    }
    ```

    IMPORTANT: suppressHydrationWarning on html is required because next-themes modifies it before React hydrates.

    Enhance globals.css with polished JARVIS-inspired color scheme:

    Light mode (:root):
    - --background: 0 0% 100%
    - --foreground: 222 47% 11%
    - --primary: 174 72% 40% (teal)
    - --primary-foreground: 0 0% 100%
    - --muted: 210 40% 96%
    - --card: 0 0% 100%
    - --border: 214 32% 91%

    Dark mode (.dark):
    - --background: 240 10% 4% (deep dark, almost black)
    - --foreground: 210 40% 98%
    - --primary: 174 72% 56% (brighter teal for dark bg)
    - --primary-foreground: 222 47% 11%
    - --muted: 217 33% 17%
    - --card: 222 47% 11%
    - --border: 217 33% 17%

    Add color utility classes that reference these variables.
  </action>
  <verify>Page loads with correct theme based on system preference, no flash</verify>
  <done>ThemeProvider integrated, CSS variables polished for both modes</done>
</task>

<task type="auto">
  <name>Task 3: Create ThemeToggle component</name>
  <files>src/components/ThemeToggle.tsx, src/app/page.tsx</files>
  <action>
    Create a client component for theme switching:

    ```typescript
    'use client';

    import { useTheme } from 'next-themes';
    import { useEffect, useState } from 'react';

    export function ThemeToggle() {
      const [mounted, setMounted] = useState(false);
      const { theme, setTheme, resolvedTheme } = useTheme();

      // Avoid hydration mismatch
      useEffect(() => {
        setMounted(true);
      }, []);

      if (!mounted) {
        return <button className="w-9 h-9" aria-label="Toggle theme" />;
      }

      return (
        <button
          onClick={() => setTheme(resolvedTheme === 'dark' ? 'light' : 'dark')}
          className="w-9 h-9 flex items-center justify-center rounded-md border border-border bg-background hover:bg-muted transition-colors"
          aria-label={`Switch to ${resolvedTheme === 'dark' ? 'light' : 'dark'} mode`}
        >
          {resolvedTheme === 'dark' ? (
            <SunIcon className="h-4 w-4" />
          ) : (
            <MoonIcon className="h-4 w-4" />
          )}
        </button>
      );
    }
    ```

    Create simple Sun and Moon icons as inline SVG components (don't add icon library dependency yet).

    Update page.tsx to display the toggle:
    - Add ThemeToggle in corner of page
    - Show current theme name for testing
    - Keep existing placeholder content
    - Style with Tailwind using the CSS variable classes (bg-background, text-foreground, etc.)
  </action>
  <verify>Toggle switches theme immediately, persists on refresh</verify>
  <done>ThemeToggle works with zero-flicker and persistence</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Theme toggle switches between light and dark mode
- [ ] Theme persists after page refresh (stored in localStorage)
- [ ] No flash of wrong theme on initial page load
- [ ] System theme preference is respected on first visit
- [ ] Both light and dark modes look polished (no broken colors)
- [ ] Toggle button shows correct icon for current theme
- [ ] `npm run build` succeeds
</verification>

<success_criteria>

- All tasks completed
- Theme switching works without flash
- Both light and dark modes have polished JARVIS-inspired aesthetics
- Theme persistence works via localStorage
- System preference detection works
  </success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-layer/01-03-SUMMARY.md`
</output>
